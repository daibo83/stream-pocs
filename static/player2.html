<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Player with Jitter Buffer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #videoPlayer {
            max-width: 640px;
            width: 100%;
            margin-bottom: 20px;
        }
        #status {
            font-weight: bold;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <video id="videoPlayer" autoplay muted controls></video>
    <button id="startButton">Start Playing</button>
    <div id="status">Not connected</div>
    <script src="MSTG_polyfill.js"></script>
    <script>
        let jitterBuffer = [];
        let baseTime = 0;
        let isPlaying = false;
        let writer;
        let trackGenerator;
        let videoStream;
        
        const videoElement = document.getElementById('videoPlayer');
        
        // Initialize MediaStreamTrackGenerator
        if (typeof MediaStreamTrackGenerator === "undefined") {
            trackGenerator = new VideoTrackGenerator();
            videoStream = new MediaStream([trackGenerator.track]);
            videoElement.srcObject = videoStream;
            writer = trackGenerator.writable.getWriter();
        } else {
            trackGenerator = new MediaStreamTrackGenerator({ kind: "video" });
            videoStream = new MediaStream([trackGenerator]);
            videoElement.srcObject = videoStream;
            writer = trackGenerator.writable.getWriter();
        }

        function handleFrame(frame) {
            insertIntoJitterBuffer(frame);
            if (!isPlaying) {
                isPlaying = true;
                processJitterBuffer();
            }
        }

        function insertIntoJitterBuffer(frame) {
            // Insert frame in sorted order by timestamp
            let index = jitterBuffer.findIndex(f => f.timestamp > frame.timestamp);
            if (index === -1) {
                jitterBuffer.push(frame);
            } else {
                jitterBuffer.splice(index, 0, frame);
            }
        }

        function processJitterBuffer() {
            if (baseTime === 0 && jitterBuffer.length > 0) {
                // Initialize baseTime with first frame's timestamp
                const firstFrame = jitterBuffer[0];
                baseTime = performance.now() - (firstFrame.timestamp / 1000);
            }

            const now = performance.now();
            const mediaTime = now - baseTime; // Current media time in milliseconds

            // Process all frames that should be displayed by now
            while (jitterBuffer.length > 0 && jitterBuffer[0].timestamp <= mediaTime * 1000) {
                const frame = jitterBuffer.shift();
                writer.write(frame);
                frame.close();
            }

            // Schedule next processing if there's remaining frames
            if (jitterBuffer.length > 0) {
                const nextFrameTime = jitterBuffer[0].timestamp / 1000; // Convert to ms
                const delay = Math.max(0, nextFrameTime - mediaTime);
                setTimeout(processJitterBuffer, delay);
            } else {
                isPlaying = false;
                baseTime = 0; // Reset for next session
            }
        }

        const statusDiv = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const websocketUrlEven = `wss://${window.location.host}/consume/test_stream_even`;
        
        let decoderConfig = {
            codec: "hev1.2.17.H186.b0",
            hardwareAcceleration: "prefer-hardware",
            optimizeForLatency: true,
        };

        let decoder;
        let websocket;

        async function startPlaying() {
            const { supported } = await VideoDecoder.isConfigSupported(decoderConfig);
            if (!supported) {
                console.error('Decoder configuration not supported');
                return;
            }

            decoder = new VideoDecoder({
                output: handleFrame,
                error: e => console.error('Decoder error:', e)
            });
            
            websocket = new WebSocket(websocketUrlEven);
            websocket.binaryType = "arraybuffer";
            
            websocket.onopen = () => {
                statusDiv.textContent = 'Connected';
                decoder.configure(decoderConfig);
            };
            var description_received = false;
                
            websocket.onmessage = (event) => {
                if (!description_received) {
                    description_received = true;
                    decoderConfig.description = event.data;
                    decoder.configure(decoderConfig);
                    return;
                }
                const chunk = new EncodedVideoChunk({
                    timestamp: 0,
                    type: "key",
                    data: event.data,
                });
                
                try {
                    decoder.decode(chunk);
                } catch (error) {
                    console.error('Decoding error:', error);
                }
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                statusDiv.textContent = 'Connection error';
            };
        }

        startButton.addEventListener('click', startPlaying);
    </script>
</body>
</html>